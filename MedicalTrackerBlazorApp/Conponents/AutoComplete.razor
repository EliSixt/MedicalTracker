<h3>AutoComplete</h3>

@*<input type="text" @onkeyup="e => OnInput(e)" value="@UserSelection" />*@


<input type="text" @oninput="e => OnInput(e)" @bind-value="@UserSelection" />
US: @UserSelection
@*TODO: What if the user deletes what they wrote, then it wouldnt be onInput, it would make sense to have "onChange", but it only gets called whenever it's out of focus*@
@*<input type="text" @bind="UserSelection" @onchange="e => OnInput(e)" />
*@

@*<input type="text" @bind="UserSelection" @bind:event="OnInput" />*@

@foreach (var item in autoCompleteSuggestions)
{

    <br />
    <button @onclick="@(() => AutoCompleteReturnValue(@item))">@item</button>
}
<h1>@SelectedSentence</h1> @*Temp: Delete*@



@code {

    private List<string>? _words;
    [Parameter]
    public List<string>? WordList
    {
        get { return _words; }
        set { _words = value; }
    }

    private string? _userSelection;

    public string? UserSelection
    {
        get { return _userSelection; }
        set { _userSelection = value; }
    }


    private string? _selectedSentence;
    [Parameter]
    public string? SelectedSentence
    {
        get { return _selectedSentence; }
        set { _selectedSentence = value; }
    }

    [Parameter]
    public EventCallback<string> SelectedWordChanged { get; set; }
    //string UserInput = "";
    List<string> autoCompleteSuggestions = new();


    //private void OnInput(KeyboardEventArgs args)
    //{
    //    var inputKey = args.Key;

    //    if (inputKey == "Delete")
    //    {
    //        var inputText = args.Key as string;
    //        if (inputText != null && WordList != null)
    //        {
    //            FilteredListGenerator(WordList, inputText);
    //        }
    //    }
    //}

    private void OnInput(ChangeEventArgs args)
    {
        var inputText = args.Value as string;
        if (inputText != null && WordList != null)
        {
            FilteredListGenerator(WordList, inputText);
        }
    }


    //public void OnKeyUpInput(string userInput)
    //{
    //    if (userInput != null && WordList != null)
    //    {
    //        FilteredListGenerator(WordList, userInput);
    //    }
    //}


    /// <summary>
    /// Creates an eight word suggestion's list, from a given dataset string list, depending on the beginning instance of the last string of the UserInput.
    /// </summary>
    /// <param name="stringList">List of strings, to base suggestions off of.</param>
    /// <param name="userInput">The string of the user's input.</param>
    public void FilteredListGenerator(List<string> stringList, string userInput)
    {
        if (userInput == null || stringList == null)
        {
            //return new List<string>();
            return;
        }

        //var suggestions = new List<string>();
        autoCompleteSuggestions.Clear();
        string lastWord = userInput.Split(' ').Last();
        List<string> filteredList = new();
        filteredList = stringList.Where(x => x.ToLower().StartsWith(lastWord.ToLower())).Take(8).ToList();
        autoCompleteSuggestions.Clear();
        //if (userInput.Split(" ").Length > 1)
        //{
        //    var newSentence = userInput.Split(" ");
        //    for (int i = 0; i < newSentence.Length - 1; i++)
        //    {
        //        SelectedSentence.Concat(newSentence[i]);
        //    }
        //}
        if (lastWord.Length > 0)
        {
            foreach (var item in filteredList)
            {
                autoCompleteSuggestions.Add(string.Join(" ", SelectedSentence, item));
            }
        }

        //return suggestions;
    }


    /// <summary>
    /// Used in the user interface, when called with a value inside, it assigns that value to a selected sentence that then gets saved.
    /// </summary>
    /// <param name="value">Value that gets assigned to SelectedSentence.</param>
    void AutoCompleteReturnValue(string value/*, ChangeEventArgs args*/)
    {
        SelectedSentence = value; //I only add values i dont delete them. Here is the problem.
        SelectedWordChanged.InvokeAsync(value);
    }
}
